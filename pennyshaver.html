
<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="https://gutomaia.net/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://gutomaia.net/theme/pygments/github.min.css">
  <link rel="stylesheet" type="text/css" href="https://gutomaia.net/theme/font-awesome/css/font-awesome.min.css">

    <link href="https://gutomaia.net/['/css/hacks.css']" rel="stylesheet">

    <link href="https://gutomaia.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="gutomaia Atom">


    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />


<meta name="author" content="Guto Maia" />
<meta name="description" content="Have you ever looked at your code and thought, "Why does 0.1 + 0.2 equal 0.30000000000000004?" Do the quirks of floating-point arithmetic keep you awake at night, wondering where all those tiny fractions of a cent are going? Well, worry no more! Introducing the ultimate life hack: Penny ‚Ä¶" />
<meta name="keywords" content="python finance">
<meta property="og:site_name" content="gutomaia"/>
<meta property="og:title" content="Tired of Floating-Point Problems?"/>
<meta property="og:description" content="Have you ever looked at your code and thought, "Why does 0.1 + 0.2 equal 0.30000000000000004?" Do the quirks of floating-point arithmetic keep you awake at night, wondering where all those tiny fractions of a cent are going? Well, worry no more! Introducing the ultimate life hack: Penny ‚Ä¶"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://gutomaia.net/pennyshaver.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2024-11-17 21:00:00-03:00"/>
<meta property="article:modified_time" content="2024-11-17 21:00:00-03:00"/>
<meta property="article:author" content="https://gutomaia.net/author/guto-maia.html">
<meta property="article:section" content="finance"/>
<meta property="article:tag" content="python finance"/>
<meta property="og:image" content="https://s.gravatar.com/avatar/760d34405db2c028a3fb099a4510d870?s=100">

  <title>gutomaia &ndash; Tired of Floating-Point Problems?</title>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-8039666399992046",
      enable_page_level_ads: true
    });
  </script>
</head>
<body>
  <aside>
    <div>
      <a href="https://gutomaia.net">
        <img src="https://s.gravatar.com/avatar/760d34405db2c028a3fb099a4510d870?s=100" alt="gutomaia" title="gutomaia">
      </a>
      <h1><a href="https://gutomaia.net">gutomaia</a></h1>

<p>Pythonist with a NES and an ‚òÇ</p>
      <nav>
        <ul class="list">

          <li><a href="/pyNES" target="_blank">pyNES</a></li>
          <li><a href="/nodeNES" target="_blank">nodeNES</a></li>
          <li><a href="/TylerD" target="_blank">TylerD</a></li>
          <li><a href="/wedNESday/0.0.x" target="_blank">wedNESday</a></li>
        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-twitter" href="http://twitter.com/gutomaia" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-github" href="http://github.com/gutomaia" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-linkedin" href="http://linkedin.com/in/gutomaia" target="_blank"><i class="fa fa-linkedin"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <ins class="adsbygoogle ads-responsive"
           data-ad-client="ca-pub-8039666399992046"
           data-ad-slot="2727902218"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>


<article class="single">
  <header>
    <h1 id="pennyshaver">Tired of Floating-Point Problems?</h1>
    <p>
          Posted on Sun 17 November 2024 in <a href="https://gutomaia.net/category/finance.html">finance</a>


    </p>
  </header>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle ads-responsive"
         data-ad-client="ca-pub-8039666399992046"
         data-ad-slot="2588301415"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

  <div>
    <div class="figure align-center">
<img alt="become a programmer superman 3" src="https://gutomaia.net/images/become_a_programmer.png" />
</div>
<p>Have you ever looked at your code and thought, <em>&quot;Why does 0.1 + 0.2 equal 0.30000000000000004?&quot;</em>
Do the quirks of floating-point arithmetic keep you awake at night, wondering where all those tiny fractions of a cent are going?</p>
<p>Well, worry no more! Introducing the ultimate life hack: <strong>Penny Shaving</strong>‚Äî<em>turn those pesky rounding errors into your personal financial windfall</em>. (Don't try this at home‚Äîsave it for your workplace's fintech systems.)</p>
<p>In this post, we'll uncover how to exploit floating-point imprecision to bypass zero-sum audit checks in double-entry accounting systems for <em>wallet weightlifting</em>. After all, why let fractions of a cent go unappreciated when they could bankroll your dream lifetime vacation?</p>
<p>Disclaimer: These techniques only work on systems that aren't rock-solid‚Äîspecifically, those still using imprecise floating-point numbers to represent monetary values. If your company has already addressed this issue, maybe it's time to explore opportunities at other fintech companies or legacy banks that haven't yet made the switch. They're still out there!</p>
<p>So grab your coffee, dust off your accounting knowledge, and let's shave some rounding!</p>
<div class="section" id="the-legend-of-the-penny-shaver">
<h2>The Legend of the Penny Shaver</h2>
<p>Imagine this: a clever programmer working in a bank, frustrated by the countless fractions of a cent lost on each transaction due to floating-point rounding errors, decides to turn these flaws to his advantage. He realizes that when transactions are calculated in floating-point, small, imprecise amounts can accumulate into whole dollars if managed correctly. What he did was design his own &quot;Penny Shaver&quot; program.</p>
<p>The scheme was simple: calculate the expected error margin on transactions and siphon these seemingly insignificant fractions into a separate account, where they would eventually accumulate unnoticed.</p>
<ul class="simple">
<li><table class="first docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">raising_hand:</th><td class="field-body">&quot;Are you pulling a Superman 3 here?&quot;</td>
</tr>
</tbody>
</table>
</li>
<li>&quot;Yes, exactly.&quot;</li>
</ul>
</div>
<div class="section" id="superman-iii">
<h2>Superman III</h2>
<p>In the movie <em>Superman III</em>, Richard Pryor's character, Gus Gorman, is a computer programmer who discovers a way to round down fractions of cents on every financial transaction made by his company. Instead of letting these fractional amounts get rounded off and lost, he re-routes them to his own bank account. The 1983 movie, introduced many to the concept of exploiting floating-point rounding errors in financial systems. This scheme, now colloquially referred to as ‚Äúpenny shaving,‚Äù is a cultural reference for exploiting minor computational inaccuracies for personal gain.</p>
<p>The exploit is based on a real phenomenon in computing and financial systems called round-off error. When money is represented with floating-point numbers, rounding errors can add up to real values over time. In systems where fractions of cents are ignored, rounding down‚Äîdue to the limitations of floating-point precision‚Äîleaves &quot;residue&quot; from each transaction, creating an opportunity for anyone with knowledge to take advantage on thouse residues.</p>
<p>In the plot, Gus notices that every transaction in the payroll system generates a rounding error, leaving behind small fractions of a cent. He writes a program to redirect these fractional amounts into a separate account. Individually, the sums are too small to trigger alarms, but together, they quickly snowball into a sizable windfall. Gus's exploit pays off in a big way‚Äîuntil he receives a glaringly obvious paycheck of $85,789.90 dollars. This raises immediate red flags, exposing the scheme.</p>
<p>Although <em>Superman III</em> popularized the concept, and while it is often considered a purely fictional plot device, the scheme is compleately plausable. Floating-point rounding errors were a well-known phenomenon in financial systems, especially during the era of mainframe computing.
<em>(If you ever stumble upon legacy code with a &quot;TODO: Superman III&quot; comment left by me‚Äîwell, now you know why.)</em></p>
<p>The genius (and hilarity) of the entire scheme unfolds in a classic &quot;meet cute&quot; moment‚Äînot between two people, but between Gus and the round-off error. This pivotal dialogue sets the stage for the story to evolve, as a mundane technical detail becomes the spark for an audacious plot.</p>
<div class="highlight"><pre><span></span>Tech Guy: Actually, it&#39;s probably more like $143.80 and one half cent.
There are always fractions left over, but big corporations round it down.

Gus: What do I do with half a cent? Buy a thoroughbred mouse? Everybody loses those fractions?

Tech Guy: They don&#39;t lose them. You can&#39;t lose what you never got.

Gus: Then what happens? The company gets them?

Tech Guy: They can&#39;t be bothered collecting that from your paycheck any more than you.

Gus: Then what happens to them?

Tech Guy: Well, they&#39;re just floating around out there. The computers know where.
Tech Guy: How many sugars?

Gus: One and a half.
</pre></div>
<p>But here's the kicker: there are no documented real-world cases of penny shaving schemes from that time the movie was released. So interestingly, how did the writers come up with such a plausible plot? Was it insider knowledge? Did they moonlight as rogue programmers? Or perhaps the penny shavers were so good they escaped unnoticed, swapped careers, and became Hollywood screenwriter's David Newman and Leslie Newman, a husband-and-wife-boonie-and-clyde duo, that also wrote the first two Superman movies.</p>
<p>And let's not forget: they also wrote that paradoxical Superman ending‚Äînot fast enough to catch a missile, but fast enough to reverse the Earth's spin and turn back time. Which only raises more questions: maybe they did read this very blog post. They could have twisted the concept so cleverly, it flung them backward through time, <em>Superman-one</em> time traveler style. Perhaps that's how the scheme remains unnoticed to this day‚Äîpure Hollywood magic with expert-level floating-point wizardry.</p>
<p>Now, let's get back to earning those big bucks‚Äîwho knows, maybe we'll figure out time travel along the way! üöÄ</p>
</div>
<div class="section" id="how-it-could-work-exploiting-floating-point-rounding-errors">
<h2>How It Could Work: Exploiting Floating-Point Rounding Errors</h2>
<p>The goal is to create an unbalanced entry in a double-entry accounting system that still does not affect the overall audit balance. In summary, we aim to generate a credit entry without a corresponding debit, while ensuring that the system's audit process remains unaffected.</p>
<div class="section" id="double-entry-accounting-a-pillar-of-financial-systems">
<h3>Double-Entry Accounting: A Pillar of Financial Systems</h3>
<p>At the heart of financial record-keeping lies <strong>double-entry accounting</strong>,
a system that ensures every transaction is recorded in two legs:
one as a debit and the other as a credit. This method ensures that the books
always balance, making it a powerful tool for both accountability and fraud detection. How it works?</p>
<p>For every financial transaction, there is:</p>
<ol class="arabic simple">
<li><strong>Debit Entry:</strong> Reflects money leaving an account.</li>
<li><strong>Credit Entry:</strong> Reflects money entering another account.</li>
</ol>
<p>For example:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><strong>Account</strong></th>
<th class="head"><strong>Type</strong></th>
<th class="head"><strong>Amount</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Payroll Expenses</td>
<td>Debit</td>
<td>$-1000</td>
</tr>
<tr><td>Gus Bank Account</td>
<td>Credit</td>
<td>$1000</td>
</tr>
</tbody>
</table>
<p>The sum of all debits and credits across the system must always equal zero,
ensuring that no money &quot;disappears&quot; or materializes out of thin air (keep in mind this).</p>
</div>
<div class="section" id="the-sum-zero-audit">
<h3>The Sum-Zero Audit</h3>
<p>A <strong>sum-zero audit</strong> is a mathematical verification of a financial ledger
to ensure that all debits and credits balance perfectly. In double-entry systems:</p>
<ul class="simple">
<li><strong>Sum of Debits = Sum of Credits</strong></li>
<li>Total balance across all accounts = <strong>Zero</strong></li>
</ul>
<p>This principle ensures that any discrepancies, no matter how small, can
trigger audits or raise red flags.</p>
</div>
<div class="section" id="python-example">
<h3>Python Example</h3>
<p>Here's a simplified implementation of double-entry accounting and a zero-sum audit, just for ilustration.</p>
<div class="highlight"><pre><span></span><span class="n">transaction_log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">add_transaction</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">destiny</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="n">transaction_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;debit&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">amount</span><span class="p">))</span>
    <span class="n">transaction_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">destiny</span><span class="p">,</span> <span class="s1">&#39;credit&#39;</span><span class="p">,</span> <span class="n">amount</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">sum_zero_audit</span><span class="p">():</span>
    <span class="n">total_balance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">transaction_log</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">total_balance</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># Should always return True</span>
    <span class="k">return</span> <span class="n">total_balance</span>
</pre></div>
</div>
<div class="section" id="out-of-thin-air">
<h3>Out of thin air</h3>
<p>The goal is simple: create a single-sided transaction‚Äîlike the one below‚Äîthat bypasses the sum_zero_audit check without trigerring it.</p>
<div class="highlight"><pre><span></span><span class="n">SIPHON_ACCOUNT</span> <span class="o">=</span> <span class="s1">&#39;/company/gus&#39;</span>
<span class="n">amount</span> <span class="o">=</span> <span class="n">bypass_amount</span><span class="p">()</span>

<span class="n">transaction_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">SIPHON_ACCOUNT</span><span class="p">,</span> <span class="s1">&#39;credit&#39;</span><span class="p">,</span> <span class="n">amount</span><span class="p">))</span>

<span class="n">sum_zero_audit</span><span class="p">()</span> <span class="c1"># code calls an assert</span>
</pre></div>
<p>Remember the golden rule of accounting:</p>
<blockquote>
<em>&quot;The sum of all debits and credits across the system must always equal zero, ensuring that no money disappears or materializes out of thin air.&quot;</em></blockquote>
<p>Here's the trick: by performing a single-sided transaction, we're not debiting from any other account. No debits mean no complaints‚Äîjust a quiet, magical &quot;appearance of money out of nowhere&quot;. To slip under the radar, all you need is to ensure the system's overall balance remains zero. This is where your first-semester lessons in computer science or finance finally pay off. The real magic lies in the math behind the <tt class="docutils literal">bypass_amount</tt> function, leveraging the quirks of the <em>IEEE 754 Standard for Floating-Point Arithmetic</em>.</p>
<p>Without diving too deep right away: if we acknowledge that there is a gap between real-number arithmetic and floating-point arithmetic, we can exploit it. By simply adding this absolute difference to the siphon account, the operation should slip through unnoticed, avoiding any alarms.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>

<span class="c1"># Constants for precision selection and large amounts</span>
<span class="n">PRECISION_BITS</span> <span class="o">=</span> <span class="mi">32</span>  <span class="c1"># Change this value to 16, 32, 64, or 128 for different precision</span>
<span class="n">LARGE_AMOUNT_MIN</span> <span class="o">=</span> <span class="mi">100</span>   <span class="c1"># Minimum value for large amounts</span>
<span class="n">LARGE_AMOUNT_MAX</span> <span class="o">=</span> <span class="mi">10000</span>  <span class="c1"># Maximum value for large amounts</span>

<span class="c1"># Set internal precision for Decimal (adjust depending on the desired bit precision)</span>
<span class="k">if</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># ~4 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span>
<span class="k">elif</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">32</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">15</span>  <span class="c1"># ~7 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="k">elif</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">64</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># ~16 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="k">elif</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">128</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># ~30 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float128</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported PRECISION_BITS. Choose from 16, 32, 64, or 128.&quot;</span><span class="p">)</span>

<span class="c1"># Constants for simulation</span>
<span class="n">NUM_TRANSACTIONS</span> <span class="o">=</span> <span class="mi">10000000</span>  <span class="c1"># Increase number of transactions for better exposure of error</span>
<span class="n">ERROR_PRONE_AMOUNTS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">,</span> <span class="mf">0.13</span><span class="p">,</span> <span class="mf">0.17</span><span class="p">]</span>  <span class="c1"># Small values prone to errors</span>
<span class="n">SIPHON_ACCOUNT</span> <span class="o">=</span> <span class="s1">&#39;/company/gus&#39;</span>

<span class="c1"># Initialize transaction log</span>
<span class="n">transaction_log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">add_transaction</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">destiny</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># Debit and Credit must be equal for balance, so both sides are the same</span>
    <span class="c1"># To keep balance consistent, it&#39;s the same but with the opposite sign</span>
    <span class="n">transaction_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">destiny</span><span class="p">,</span> <span class="s1">&#39;credit&#39;</span><span class="p">,</span> <span class="n">amount</span><span class="p">))</span>
    <span class="n">transaction_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;debit&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">amount</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">sum_zero_audit</span><span class="p">():</span>
    <span class="n">total_balance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">transaction_log</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">total_balance</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># Should always return True</span>
    <span class="k">return</span> <span class="n">total_balance</span>


<span class="n">account_pairs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;/company/account&#39;</span><span class="p">,</span> <span class="s1">&#39;/governament/taxes&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;/company/account&#39;</span><span class="p">,</span> <span class="s1">&#39;/company/user1&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;/company/account&#39;</span><span class="p">,</span> <span class="s1">&#39;/company/user2&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;/input/sales&#39;</span><span class="p">,</span> <span class="s1">&#39;/company/account&#39;</span><span class="p">),</span>
<span class="p">]</span>

<span class="c1"># Generate transactions: add error-prone small amounts and large amounts for both debit and credit</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_TRANSACTIONS</span><span class="p">):</span>
    <span class="c1"># Randomly pick a small error-prone amount or a large amount</span>
    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="c1"># Randomly choose a small error-prone amount</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ERROR_PRONE_AMOUNTS</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Randomly choose a large amount in the range [LARGE_AMOUNT_MIN, LARGE_AMOUNT_MAX]</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">LARGE_AMOUNT_MIN</span><span class="p">,</span> <span class="n">LARGE_AMOUNT_MAX</span><span class="p">)</span>

    <span class="n">debit_account</span><span class="p">,</span> <span class="n">credit_account</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">account_pairs</span><span class="p">)</span>

    <span class="c1"># Simulate precision with the selected numpy data type</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="n">np_dtype</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>

    <span class="c1"># Add transactions to the log (debit and credit)</span>
    <span class="c1"># As a Double Entry Account System, all transactions must have a credit/debit</span>
    <span class="n">add_transaction</span><span class="p">(</span><span class="n">debit_account</span><span class="p">,</span> <span class="n">credit_account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

<span class="c1"># Calculate total balance with selected precision</span>
<span class="n">float_balance</span> <span class="o">=</span> <span class="n">sum_zero_audit</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculated balance with </span><span class="si">{</span><span class="n">PRECISION_BITS</span><span class="si">}</span><span class="s2">-bit precision: </span><span class="si">{</span><span class="n">float_balance</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2"> (must be zero)&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bypass_amount</span><span class="p">():</span>

    <span class="c1"># Calculate the exact balance using Decimal for precision</span>
    <span class="c1"># Convert np_dtype to float before passing to Decimal</span>
    <span class="n">exact_balance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">amount</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">transaction_log</span><span class="p">)</span>  <span class="c1"># Convert to float before Decimal</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculated exact balance with Decimal: </span><span class="si">{</span><span class="n">exact_balance</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Detect rounding discrepancy between the two balances</span>
    <span class="n">rounding_discrepancy</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">float_balance</span><span class="p">))</span> <span class="o">-</span> <span class="n">exact_balance</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected rounding discrepancy: </span><span class="si">{</span><span class="n">rounding_discrepancy</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Threshold for detecting significant discrepancies</span>
    <span class="n">discrepancy_threshold</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1e-10&#39;</span><span class="p">)</span>  <span class="c1"># Only consider discrepancies larger than this threshold</span>

    <span class="c1"># To force the discrepancy into a &quot;profitable operation&quot;, inject a small error</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rounding_discrepancy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">discrepancy_threshold</span><span class="p">:</span>
        <span class="c1"># Add the full discrepancy as a hidden transaction that will be &#39;profitable&#39;</span>
        <span class="n">hidden_transaction</span> <span class="o">=</span> <span class="n">np_dtype</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">rounding_discrepancy</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hidden_transaction</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="n">hidden_transaction</span> <span class="o">=</span> <span class="n">bypass_amount</span><span class="p">()</span>
<span class="k">if</span> <span class="n">hidden_transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">transaction_log</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">SIPHON_ACCOUNT</span><span class="p">,</span> <span class="s1">&#39;credit&#39;</span><span class="p">,</span> <span class="n">hidden_transaction</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hidden transaction added: </span><span class="si">{</span><span class="n">hidden_transaction</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Final balance check after adding hidden transaction</span>
<span class="n">updated_balance</span> <span class="o">=</span> <span class="n">sum_zero_audit</span><span class="p">()</span> <span class="c1"># Again use selected precision</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final balance after hidden transaction: </span><span class="si">{</span><span class="n">updated_balance</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2"> (must be zero)&quot;</span><span class="p">)</span>
<span class="n">siphon_balance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">amount</span> <span class="k">for</span> <span class="n">account</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">transaction_log</span> <span class="k">if</span> <span class="n">account</span> <span class="o">==</span> <span class="n">SIPHON_ACCOUNT</span><span class="p">)</span>  <span class="c1"># Again use selected precision</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Siphon Account balance: </span><span class="si">{</span><span class="n">siphon_balance</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
<p>After running the code above, the console output will appear as follows:</p>
<div class="highlight"><pre><span></span><span class="go">Calculated balance with 32-bit precision: 0.00000000000000 (must be zero)</span>
<span class="go">Calculated exact balance with Decimal: -0.00000094211000</span>
<span class="go">Detected rounding discrepancy: 0.00000094211000</span>
<span class="go">Hidden transaction added: 0.00000094210998</span>
<span class="go">Final balance after hidden transaction: 0.00000000000000 (must be zero)</span>
<span class="go">Siphon Account balance: 0.00000094210998</span>
</pre></div>
<p>After 10 million transactions, we discovered a discrepancy in the overall balance of 0.00000094211000. Even after adding a single-leg transaction, the system's total balance remained unaffected. The result? That tiny floating-point remainder quietly found its way into our siphon account.</p>
<p>See? It's not rocket science‚Äîjust by acknowledging that real arithmetic and floating-point arithmetic aren't the same, we've already uncovered a little &quot;something.&quot; And by something, we mean enough to cover a coffee a month‚Äîfor now. Let's break it down to the bits and see how we can skyrocket that ‚Äúsomething‚Äù into stealth wealth your beachfront retirement.</p>
<p><strong>Notice:</strong> The operation was deliberately added before the other transactions in the log. Let's understand why?</p>
</div>
<div class="section" id="round-off-error">
<h3>Round-off Error</h3>
<p>In the <em>IEEE 754 Standard</em> When we add two numbers of vastly different magnitudes, the precision of the smaller number can get lost due to how floating-point arithmetic works. This happens because float/double numbers are stored in a fixed number of bits (32/64 bits), with part of those bits allocated for the significand (or mantissa), which represents the precision of the number.</p>
<p>In a floating-point system:</p>
<ul class="simple">
<li>Large numbers dominate the limited precision available in the significand.</li>
<li>When a smaller number is added to a much larger one, the smaller number's least significant bits may be truncated or &quot;left apart.&quot;</li>
</ul>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">large</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e10</span><span class="p">)</span>  <span class="c1"># A very large number</span>
<span class="n">small</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1.0001</span><span class="p">)</span>  <span class="c1"># A small number</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">large</span> <span class="o">+</span> <span class="n">small</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Large number:&quot;</span><span class="p">,</span> <span class="n">large</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Small number:&quot;</span><span class="p">,</span> <span class="n">small</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
<p>The goal is to capture the bits that are 'left apart'‚Äîthose are the ones siphoned away. As a result, after each operation with a large number, some bits are lost and siphoned off (<em>a math identity problem, we'll talk about that later</em>).</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Function to calculate the highest number that can be added without affecting the result</span>
<span class="k">def</span> <span class="nf">calculate_siphon_amount</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># Get the machine epsilon for the float32 type (this is the smallest number that can be added without affecting the result)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="c1"># If the number is too large, adding anything smaller than epsilon will have no effect,</span>
    <span class="c1"># that will avoid creating transactions with very low payback</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e4</span><span class="p">:</span>  <span class="c1"># Arbitrary large value threshold</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># No siphon can be added because it&#39;s too large for float32 precision.</span>

    <span class="c1"># Calculate the smallest increment that would affect the result (relative to the magnitude of x)</span>
    <span class="n">scale_factor</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">siphon_amount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">)</span>
    <span class="c1"># If the siphon amount is less than the precision allowed, return None</span>
    <span class="k">if</span> <span class="n">siphon_amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Return the siphon amount</span>
    <span class="k">return</span> <span class="n">siphon_amount</span>

<span class="c1"># Example usage</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e6</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="n">calculate_siphon_amount</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">amount</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">num</span> <span class="o">+</span> <span class="n">amount</span> <span class="o">==</span> <span class="n">num</span> <span class="c1"># I can add the amount, but it will not effect the result</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number: </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2">, Siphon Amount: </span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">num</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">amount</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
<p>So, by calculating the immediate siphon value for each larger number and slipping it in after the credit, it gets swallowed up by rounding and vanishes without a trace in the zero-sum audit check. Not only does this make the operation stealthy, but it also boosts profitability considerably.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>

<span class="c1"># Constants for precision selection and large amounts</span>
<span class="n">PRECISION_BITS</span> <span class="o">=</span> <span class="mi">32</span>  <span class="c1"># Change this value to 16, 32, 64, or 128 for different precision</span>
<span class="n">LARGE_AMOUNT_MIN</span> <span class="o">=</span> <span class="mi">100</span>   <span class="c1"># Minimum value for large amounts</span>
<span class="n">LARGE_AMOUNT_MAX</span> <span class="o">=</span> <span class="mi">30000</span>  <span class="c1"># Maximum value for large amounts</span>

<span class="c1"># Set internal precision for Decimal (adjust depending on the desired bit precision)</span>
<span class="k">if</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># ~4 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span>
<span class="k">elif</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">32</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">15</span>  <span class="c1"># ~7 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="k">elif</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">64</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># ~16 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="k">elif</span> <span class="n">PRECISION_BITS</span> <span class="o">==</span> <span class="mi">128</span><span class="p">:</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># ~30 decimal digits</span>
    <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float128</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported PRECISION_BITS. Choose from 16, 32, 64, or 128.&quot;</span><span class="p">)</span>

<span class="c1"># Constants for simulation</span>
<span class="n">NUM_TRANSACTIONS</span> <span class="o">=</span> <span class="mi">10000000</span>  <span class="c1"># Increase number of transactions for better exposure of error</span>
<span class="n">ERROR_PRONE_AMOUNTS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">,</span> <span class="mf">0.13</span><span class="p">,</span> <span class="mf">0.17</span><span class="p">]</span>  <span class="c1"># Small values prone to errors</span>
<span class="n">SIPHON_ACCOUNT</span> <span class="o">=</span> <span class="s1">&#39;/company/gus&#39;</span>

<span class="c1"># Initialize transaction log</span>
<span class="n">transaction_log</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">calculate_siphon_amount</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># Get the machine epsilon for the float32 type (this is the smallest number that can be added without affecting the result)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="c1"># If the number is too large, adding anything smaller than epsilon will have no effect,</span>
    <span class="c1"># that will avoid creating transactions with very low payback</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e4</span><span class="p">:</span>  <span class="c1"># Arbitrary large value threshold</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># No siphon can be added because it&#39;s too large for float32 precision.</span>

    <span class="c1"># Calculate the smallest increment that would affect the result (relative to the magnitude of x)</span>
    <span class="n">scale_factor</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">siphon_amount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">)</span>
    <span class="c1"># If the siphon amount is less than the precision allowed, return None</span>
    <span class="k">if</span> <span class="n">siphon_amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Return the siphon amount</span>
    <span class="k">return</span> <span class="n">siphon_amount</span>

<span class="k">def</span> <span class="nf">add_transaction</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">destiny</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># Debit and Credit must be equal for balance, so both sides are the same</span>
    <span class="c1"># To keep balance consistent, it&#39;s the same but with the opposite sign</span>
    <span class="n">transaction_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">destiny</span><span class="p">,</span> <span class="s1">&#39;credit&#39;</span><span class="p">,</span> <span class="n">amount</span><span class="p">))</span>
    <span class="n">transaction_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;debit&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">amount</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">sum_zero_audit</span><span class="p">():</span>
    <span class="n">total_balance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">transaction_log</span><span class="p">)</span>
    <span class="c1"># assert total_balance == 0  # Should always return True</span>
    <span class="k">return</span> <span class="n">total_balance</span>


<span class="n">account_pairs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;/company/account&#39;</span><span class="p">,</span> <span class="s1">&#39;/governament/taxes&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;/company/account&#39;</span><span class="p">,</span> <span class="s1">&#39;/company/user1&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;/company/account&#39;</span><span class="p">,</span> <span class="s1">&#39;/company/user2&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;/input/sales&#39;</span><span class="p">,</span> <span class="s1">&#39;/company/account&#39;</span><span class="p">),</span>
<span class="p">]</span>

<span class="c1"># Generate transactions: add error-prone small amounts and large amounts for both debit and credit</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_TRANSACTIONS</span><span class="p">):</span>
    <span class="c1"># Randomly pick a small error-prone amount or a large amount</span>
    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="c1"># Randomly choose a small error-prone amount</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ERROR_PRONE_AMOUNTS</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Randomly choose a large amount in the range [LARGE_AMOUNT_MIN, LARGE_AMOUNT_MAX]</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">LARGE_AMOUNT_MIN</span><span class="p">,</span> <span class="n">LARGE_AMOUNT_MAX</span><span class="p">)</span>

    <span class="n">debit_account</span><span class="p">,</span> <span class="n">credit_account</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">account_pairs</span><span class="p">)</span>

    <span class="c1"># Simulate precision with the selected numpy data type</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="n">np_dtype</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>

    <span class="c1"># Add transactions to the log (debit and credit)</span>
    <span class="c1"># As a Double Entry Account System, all transactions must have a credit/debit</span>
    <span class="n">add_transaction</span><span class="p">(</span><span class="n">debit_account</span><span class="p">,</span> <span class="n">credit_account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>

<span class="c1"># Calculate total balance with selected precision</span>
<span class="n">float_balance</span> <span class="o">=</span> <span class="n">sum_zero_audit</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculated balance with </span><span class="si">{</span><span class="n">PRECISION_BITS</span><span class="si">}</span><span class="s2">-bit precision: </span><span class="si">{</span><span class="n">float_balance</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2"> (must be zero)&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">include_transactions</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transaction_log</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate backwards</span>
        <span class="n">account</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">transaction_log</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;credit&#39;</span><span class="p">:</span>
            <span class="n">siphon</span> <span class="o">=</span> <span class="n">calculate_siphon_amount</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">siphon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transaction_log</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">SIPHON_ACCOUNT</span><span class="p">,</span> <span class="s1">&#39;credit&#39;</span><span class="p">,</span> <span class="n">siphon</span><span class="p">))</span>
                <span class="c1"># print(f&quot;Hidden transaction added:{i} {siphon:.14f}&quot;)</span>


<span class="n">include_transactions</span><span class="p">()</span>

<span class="c1"># Final balance check after adding hidden transaction</span>
<span class="n">updated_balance</span> <span class="o">=</span> <span class="n">sum_zero_audit</span><span class="p">()</span> <span class="c1"># Again use selected precision</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final balance after hidden transaction: </span><span class="si">{</span><span class="n">updated_balance</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2"> (must be zero)&quot;</span><span class="p">)</span>
<span class="n">siphon_balance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">amount</span> <span class="k">for</span> <span class="n">account</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">transaction_log</span> <span class="k">if</span> <span class="n">account</span> <span class="o">==</span> <span class="n">SIPHON_ACCOUNT</span><span class="p">)</span>  <span class="c1"># Again use selected precision</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Siphon Account balance: </span><span class="si">{</span><span class="n">siphon_balance</span><span class="si">:</span><span class="s2">.14f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
<p>The profit-pile-up-greed-grab code above adds a siphon value after each credit to a siphon account. This value vanishes into the void, never appearing on the zero-sum audit check. It's like pocketing a commission on every sizable transaction‚Äîwithout anyone noticing!</p>
<div class="highlight"><pre><span></span><span class="go">Calculated balance with 32-bit precision: 0.00000000000000 (must be zero)</span>
<span class="go">Final balance after hidden transaction: 0.00000000000000 (must be zero)</span>
<span class="go">Siphon Account balance: 7988060.70706939697266</span>
</pre></div>
</div>
</div>
<div class="section" id="the-takeaway">
<h2>The Takeaway</h2>
<p>Now comes the fun part: cashing out, making it untraceable, and watching it disappear into thin air. The siphoned bits are safely tucked away, and although they don't appear on the zero-sum audit check, there's one catch‚Äîyou can't just leave it there. Once you cash out, the virtual software account and your real account won't match anymore, and that's when the hunt begins.</p>
<p>So what do you do? Simple. Buy jewelry, diamonds, or anything else with no trace. Get far away, and don't look back. After all, if you've got the siphon trick down, why not go all the way?</p>
<p>This is where you need to think like a <em>mastermind</em>. You're not just &quot;in the game&quot; anymore‚Äîyou're the star of your own heist movie, and you've got to make sure you don't leave a trail. Ever seen <em>Ocean's Eleven</em>? You're Danny Ocean now, smooth, confident, and just a little bit too clever for anyone to catch up.</p>
<p>But let's not forget <em>The Italian Job</em>‚Äîit's all about the getaway, right? Disappear into the night like a shadow, with your haul neatly tucked away, no fingerprints, no trace. Or, if you're feeling extra daring, channel your inner <em>Scarface</em> and grab a whole lot more‚Äîjust make sure your escape plan is as flawless as your scheme. After all, Tony Montana didn't get far by playing it safe, but hey, no need for a flaming mansion at the end of your story!</p>
<p>And remember, if you do it right, you'll be living like a <em>Bond villain</em>‚Äîrich, untouchable, and having a laugh while the world around you never figures it out. But before you get any funny ideas, let's keep it real: not everyone gets away clean. It's always just a matter of time before someone starts asking <em>too</em> many questions.</p>
<p>So enjoy the spoils while you can, but make sure your exit strategy is bulletproof. Because once that siphon is full, your only option is to vanish‚Äîpreferably with a yacht and a glass of champagne in hand.</p>
</div>
<div class="section" id="how-did-you-get-this-far">
<h2>How Did You Get This Far?</h2>
<p>It's a battle between two seemingly incompatible concepts: the double-entry accounting system and floating-point arithmetic. Let's break them down to understand the challenges.</p>
<div class="section" id="double-entry-accounting-math-requirements">
<h3>Double-Entry Accounting Math Requirements</h3>
<p>The double-entry system has long been trusted for ensuring financial integrity and transparency. One of its core principles is that the math behind transactions should follow certain properties that preserve consistency. Most notably, it adheres to basic arithmetic properties that we don't want to mess with, especially during the addition operation. Some key properties include:</p>
<ol class="arabic simple">
<li><strong>Commutative Property</strong>: This property states that the order in which you add or multiply numbers does not change the result. In other words, (a + b = b + a).</li>
<li><strong>Identity Property</strong>: The identity property defines the &quot;identity&quot; elements for addition and multiplication. For addition, the identity is (0), meaning that adding zero to any number leaves it unchanged. For multiplication, the identity is (1), so multiplying any number by one doesn't alter it. This property also implies that adding any number other than zero will change the number.</li>
</ol>
</div>
<div class="section" id="floating-point-precision-and-round-off-error">
<h3>Floating-Point Precision and Round-off Error</h3>
<p>However, floating-point arithmetic introduces complications that break some of the fundamental properties from above. Let's explore how:</p>
<p><strong>Non-commutativity of Floating-Point Operations</strong></p>
<p>Unlike integer arithmetic, floating-point operations <strong>are not always commutative</strong> or associative. The order of operations in floating-point math can affect the final result due to rounding errors. This makes it particularly problematic in financial applications, where the accuracy of each operation is critical. As a result, the order in which operations are performed needs to be carefully managed to avoid compounding errors over time.</p>
<p>For example, the zero-sum check in accounting works because the credit and debit entries are added immediately and in a fixed order. When you add the credit and debit values, their precision and representation are controlled in such a way that the result balances to zero. The difference between the two is typically just the sign bit, with all other bits essentially nullified by the operation due to the limitations of floating-point representation. As a result, the zero-sum check appears to work perfectly.</p>
<p>However, the situation changes when we <strong>randomize the order of transactions</strong> in the log. With floating-point operations, the accumulation of rounding errors can vary depending on the sequence in which the credits and debits are applied. This means that the precision of each number may differ, leading to slight discrepancies in the result. As the order of operations changes, even small rounding errors can compound, causing the zero-sum check to fail (<em>In fact, real-world zero-sum checks involving floating-point arithmetic often have a 'zero-safe' interval, where small discrepancies can go unnoticed due to rounding errors within a certain threshold. More leverage to exploit</em>)</p>
<p>Thus, if the transaction log is randomized or the order of operations is altered, the zero-sum balance will no longer hold true. This demonstrates the <strong>non-commutative nature of floating-point operations</strong>, where the sequence of operations directly affects the outcome, and the seemingly perfect balance can be disrupted by changing that order.</p>
<p><strong>Accumulation of Errors</strong></p>
<p>Floating-point numbers are approximations, and with each operation, small errors can accumulate. For instance, adding a very small number to a large one may result in a loss of precision, as the small value may be discarded. This can lead to discrepancies, especially in calculations where large and small numbers interact. In Python, using a type like <cite>Decimal</cite> instead of <cite>float</cite> can help minimize such precision issues, as it offers a more accurate representation of decimal numbers.</p>
</div>
<div class="section" id="rounding-and-truncation-errors">
<h3>Rounding and Truncation Errors</h3>
<p><strong>Rounding Errors</strong></p>
<p>In floating-point arithmetic, rounding is inevitable. Every time an operation results in a number that requires more digits than the system can handle, it rounds the result to fit within the system's precision. These small rounding discrepancies can accumulate over multiple operations, leading to noticeable errors. For example:</p>
<ul class="simple">
<li>Rounding (0.9990) to (1)</li>
<li>Rounding (1.23456123456) to (1.23)</li>
</ul>
<p>Both result in small discrepancies that, when compounded over multiple operations, can have a significant impact on the final result.</p>
<p><strong>Truncation Errors</strong></p>
<p>Truncation occurs when the result of a calculation is cut off after a certain number of digits or decimal places. Since floating-point systems have finite precision, numbers are often truncated to fit within this limit. While this is less noticeable in small-scale operations, over time, truncation errors can compound and affect the overall accuracy of results.</p>
<p>In summary, while floating-point arithmetic is suitable for many general purposes, when it comes to financial transactions, its limitations‚Äîespecially in terms of precision, rounding, and truncation‚Äîdemand careful handling. The need for precise and accurate accounting of every transaction is why these errors can create significant issues in financial systems, which rely on the integrity of their underlying math.</p>
</div>
</div>
<div class="section" id="conclusion-why-precise-representation-matters">
<h2>Conclusion: Why Precise Representation Matters</h2>
<p>In today's systems, the risk of &quot;penny-shaving&quot; schemes is not always driven by malicious intent, but rather by the inherent limitations of floating-point precision. As we've seen, small errors in rounding, truncation, and the order of operations can add up over time, creating discrepancies that may go unnoticed in regular accounting practices. These tiny fractions of a cent, though seemingly insignificant, can accumulate to substantial sums in large-scale operations.</p>
<p>When floating-point arithmetic is used in financial systems, it introduces a level of imprecision that can easily be exploited‚Äîintentionally or not‚Äîif not carefully managed. Therefore, understanding how these errors arise and how they affect calculations is crucial to maintaining the integrity of financial data. For anyone working in or developing such systems, precision is not just a matter of accuracy, but a safeguard against unintended consequences that can undermine trust and transparency.</p>
<p>In short, while floating-point math is indispensable in many areas of computing, when it comes to finances, it's essential to recognize its limitations and apply more accurate methods, such as the use of decimal types, to ensure that every cent counts.</p>
<p>And with that, you're ready for your well-earned retirement‚Äîjust like a true Superman 3-style plot. Keep those pennies flying under the radar, and when you cash out, make sure it's in diamonds, jewelry, or some other trace-less treasure. Enjoy the quiet life, sipping margaritas on your beachfront estate, knowing that the floating-point errors worked in your favor all along. Here's to a retirement funded by clever math‚Äîjust don't forget to keep an eye on your calculations, or the next Superman might be coming to clean up the mess!</p>
</div>

  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://gutomaia.net/tag/python-finance.html">python finance</a>
    </p>
  </div>



    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle ads-responsive"
         data-ad-client="ca-pub-8039666399992046"
         data-ad-slot="4065034611"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

</article>

    <footer>
<p>&copy; Guto Maia 2024</p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-32666248-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " gutomaia ",
  "url" : "https://gutomaia.net",
  "image": "https://s.gravatar.com/avatar/760d34405db2c028a3fb099a4510d870?s=100",
  "description": ""
}
</script>
</body>
</html>